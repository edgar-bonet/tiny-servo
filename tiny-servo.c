/*
 * tiny-servo.c: Control 20 servos with a 28-pin AVR chip.
 *
 * This programs turns an AVR into a servo controller with an I2C
 * interface. The control pulses are generated by timed busy loops, with
 * interrupts disabled, each loop driving 4 pulses. Interrupts are thus
 * disabled during 5 consecutive periods of 2 ms, and this repeats every
 * 20 ms. Disabling the servo updates (mode 0) will avoid blocking
 * interrupts and make the I2C interface more responsive.
 *
 * Compatible MCUs:
 *   ATtiny(48,88), ATmega(48A,48PA,88A,88PA,168A,168PA,328,328P)
 *
 * Pin mapping:
 *   servo:   0-  7,   8- 15,  16- 19
 *   pin:   PD0-PD7, PB0-PB7, PC0-PC3
 *
 * I2C interface:
 *   The interface exposes a set of 22 8-bit registers, numbered from 0
 *   to 21, with an auto-incrementing pointer.
 *
 * Register map:
 *   0-19: Targets for servos 0-19. These are the values the set points
 *       should eventually reach. The width of the pulse sent to the
 *       servo is (1000 + 4 * set_point) microseconds.
 *       Range: 0 -> 1.0 ms, 255 -> 2.02 ms.
 *   20: Speed. This is the maximum amount the set point can change on
 *       each update. There are 50 updates per second. Setting this to
 *       255 will allow instantaneous tracking of the targets.
 *   21: Mode. The valid modes are:
 *       0: do not drive the servos
 *       1: keep the current set point
 *       3: move the set point towards the target at the specified speed
 *
 * Copyright (c) 2015 Edgar Bonet Orozco.
 * This file is part of the Tiny Servo Controller project, licensed
 * under the terms of the MIT license. See file LICENSE for details.
 */

#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/twi.h>


/***********************************************************************
 * Exposed interface.
 */

#ifndef I2C_ADDRESS
#  define I2C_ADDRESS 0x53  /* like "53RVOS" ;-) */
#endif

/* User-visible registers. */
volatile uint8_t regs[22];

/* Special registers. */
#define REG_SPEED 20
#define REG_MODE  21

/* Bits of the MODE register */
#define MODE_DRIVE  0x01
#define MODE_UPDATE 0x02


/***********************************************************************
 * I2C driver.
 */

/*
 * Default setting for the TWI control register: acknowledge whatever we
 * receive next.
 */
#define TWI_ACK_NEXT  (_BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA))

ISR(TWI_vect)
{
    static uint8_t address;
    static uint8_t address_valid;
    uint8_t next_TWCR = TWI_ACK_NEXT;

    switch (TW_STATUS) {

        /* Slave receiver. */
        case TW_SR_SLA_ACK:
        case TW_SR_GCALL_ACK:
            address_valid = 0;
            break;
        case TW_SR_DATA_ACK:
        case TW_SR_GCALL_DATA_ACK:
        case TW_SR_DATA_NACK:
        case TW_SR_GCALL_DATA_NACK:
            if (address_valid) {
                if (address < 22)
                    regs[address++] = TWDR;
                /* else reset TWEA bit to send NACK? */
            }
            else {
                address = TWDR;
                address_valid = 1;
            }
            break;

        /* Slave transmitter. */
        case TW_ST_SLA_ACK:
        case TW_ST_DATA_ACK:
            TWDR = address<22 ? regs[address++] : 0;
            break;

        /* Error. */
        case TW_BUS_ERROR:
            next_TWCR |= _BV(TWSTO);  /* release the bus */
            /* fallthrough */
        default:
            address_valid = 0;
    }
    TWCR = next_TWCR;
}


/***********************************************************************
 * Main program: drive the servos.
 */

/*
 * Send pulses to 4 consecutive bits of port, starting at first_bit.
 * Implemented in pulse.S.
 */
extern void pulse(volatile uint8_t *port,
        uint8_t first_bit, uint8_t lengths[4]);

int main(void)
{

    /* Set the clock to 8 MHz. */
    CLKPR = _BV(CLKPCE);    /* enable prescaler change */
#ifdef ARDUINO
    CLKPR = _BV(CLKPS0);    /* prescaler = 2 */
#else                       /* assume internal 8 MHz */
    CLKPR = 0;              /* prescaler = 1 */
#endif

    /* Configure Timer 1 to raise OCF1A every 20 ms. */
    TCCR1B = _BV(WGM12)         /* mode 4: CTC */
           | _BV(CS11);         /* F_CPU/8, 1 us/tick */
    OCR1A = 19999;              /* 20000 us */
    TIFR1 |= _BV(OCF1A);        /* clear output compare flag */

#ifndef NO_PULLUP
    /* Enable internal pullups on the I2C lines. */
    PORTC = _BV(PC4) | _BV(PC5);
#endif

    /* Set all other GPIO pins as outputs. */
    DDRD = 0xff;
    DDRB = 0xff;
    DDRC = 0x0f;

    /* Initialize I2C interface. */
    TWAR = (I2C_ADDRESS << 1) | _BV(TWGCE);
    TWCR = TWI_ACK_NEXT;

    sei();

    /* Main loop. */
    for (;;) {
        static uint8_t set_point[20];
        uint8_t mode = regs[REG_MODE];

        /* Wait for the start of the next 20 ms slot. */
        loop_until_bit_is_set(TIFR1, OCF1A);
        TIFR1 |= _BV(OCF1A);    /* clear flag */

        /* Send pulses. */
        if (mode & MODE_DRIVE) {
            pulse(&PORTD, 0, &set_point[ 0]);
            pulse(&PORTD, 4, &set_point[ 4]);
            pulse(&PORTB, 0, &set_point[ 8]);
            pulse(&PORTB, 4, &set_point[12]);
            pulse(&PORTC, 0, &set_point[16]);
        }

        /* Update set points. */
        if (mode & MODE_UPDATE) {
            uint8_t i;
            uint8_t speed = regs[REG_SPEED];
            for (i = 0; i < 20; i++) {
                uint8_t target = regs[i];
                if (set_point[i] < target) {
                    if (set_point[i] + speed > target)
                        set_point[i] = target;
                    else
                        set_point[i] += speed;
                }
                else {
                    if (set_point[i] - speed < target)
                        set_point[i] = target;
                    else
                        set_point[i] -= speed;
                }
            }
        }

    }
}
